---
# Override the name of the the Varnish Enterprise chart and its components.
nameOverride: ""

# Override the full name of the Varnish Enterprise chart and its components.
fullnameOverride: ""

global:
  # Sets the secret to use to pull images.
  imagePullSecrets: []
  #imagePullSecrets:
  #  - name: quay.io-varnish-software
  # Set which container image & tag to use when initContainers are spun up
  initContainer:
    image: "busybox"
    tag: "1.36"
  # Sets the securityContext of the Pod.
  podSecurityContext:
    fsGroup: 999

  # Sets the securityContext for all containers.
  securityContext:
    runAsUser: 999
    runAsNonRoot: true

  # Sets the annotations for all workload resources.
  annotations: {}

  # Sets the annotations for all pod templates.
  podAnnotations: {}

  # Sets the labels for all workload resources.
  labels: {}

  # Sets the labels for all pod templates.
  podLabels: {}

  # Configures a resource limits for all containers.
  resources: {}
  #resources:
  #  limits:
  #    cpu: 100m
  #    memory: 128Mi
  #  requests:
  #    cpu: 100m
  #    memory: 128Mi

  # Configures NATS discovery. Note that this is *not* for deploying internal NATS server
  # but instead for other components to discover NATS server.
  natsServer:
    # Configures Varnish Controller Agent to use external NATS server.
    # Ignored if `global.natsServer.internal.enabled` is set to `true`.
    externalAddress: ""

    internal:
      # Configures Varnish Controller Agent to use internal NATS server.
      enabled: true

      # Configures the namespace internal NATS is deployed to. If left blank, the
      # current namespace is used instead.
      namespace: ""

      # Configures the release name for NATS is deployed to. Use "varnish-controller"
      # if left blank.
      releaseName: ""

      # Configures NATS password from a Kubernetes secret. By default, it uses an
      # auto-generated password from a "varnish-controller-credentials" secret.
      passwordFrom:
        name: varnish-controller-credentials
        key: nats-varnish-password

      # Configures the NATS internal cluster domain name. Only change if NATS is deployed
      # on a separate cluster.
      clusterDomain: "cluster.local"

serviceAccount:
  # Specifies whether a service account should be created
  create: true

  # Labels to add to the service account. Can be set as a templated string.
  labels: {}

  # Annotations to add to the service account. Can be set as a templated string.
  annotations: {}

  # The name of the service account to use. If not set and create is true, a name
  # is generated using the fullname template
  name: ""

# Configures Varnish Enterprise server.
server:
  replicas: 1

  # Sets the deployment kind. Can be either a Deployment or StatefulSet. StatefulSet
  # is required to enable MSE with Persistent Disk.
  kind: "Deployment"

  # Sets the extra labels for the deployment. Can be set as a templated string.
  labels: {}

  # Sets the extra annotations for the deployment. Can be set as a templated string.
  annotations: {}

  # Sets the deployment strategy. Can be set as a templated string.
  # https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  strategy: {}

  # Sets the updateStrategy for StatefulSet and DaemonSet. Can be set as a templated string.
  # https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  # https://kubernetes.io/docs/tasks/manage-daemon/update-daemon-set/
  updateStrategy: {}

  # Enables hostNetwork to expose Varnish directly on the node.
  hostNetwork: false

  # Enables shared process namespace. May be required in case `extraContainers` needs to
  # notify other process in the same Pod using UNIX signals (e.g. varnish-discovery
  # and varnish-broadcaster).
  # https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/
  shareProcessNamespace: false

  http:
    enabled: true
    port: 6081

  tls:
    enabled: false

    # Sets the port to listen to. Must be the same port as in config (see below).
    # Use the default TLS port 6443 if no config is provided.
    port: 6443

    # Configures the In-Process TLS. Can be set as a templated string. The certificate
    # can be mounted into the container using volumeMounts.
    #
    # See also https://docs.varnish-software.com/varnish-cache-plus/features/core-ssl/
    config: ""
    #config: |
    #  frontend = {
    #    host = ""
    #    port = "{{ .Values.server.tls.port }}"
    #  }
    #
    #  pem-file = "/etc/varnish/certs/example.pem"

    # Use the content of the given file path as TLS configuration. The file will be
    # parsed as templated string. Will override "server.tls.config" if set. Note that
    # the file must be placed inside the files/ directory in the Helm chart
    # itself.
    configFile: ""
    #configFile: "files/tls.cfg"

  admin:
    # Sets the address for Varnish management interface to listens to.
    address: "127.0.0.1"

    # Sets the port for Varnish management interface to listens to.
    port: 6082

  # A list of extra addresses and ports to listen.
  #
  #     name        Name of this listen (accessible in VCLs via local.socket).
  #
  #     proto       The proto to listen as (http or proxy)
  #
  #     TCP socket:
  #
  #       port        The port to listens as. Required unless path is set.
  #
  #       address     The IP address to listens as
  #
  #     UNIX socket:
  #
  #       path        The path to socket. Required unless port is set.
  #
  #       mode        The mode octet for the socket (0644, 0755, etc.)
  #
  #       user        The user for the socket
  #
  #       group       The group for the socket
  #
  extraListens: []
  #  - name: proxy
  #    address: "127.0.0.1"
  #    port: 8088
  #    proto: "PROXY"
  #
  #  - name: proxy-sock
  #    path: "/tmp/varnish-proxy.sock"
  #    user: "www"
  #    group: "www"
  #    mode: "0700"
  #    proto: "PROXY"

  # Sets the extra environment variables for Varnish Enterprise. Can be set as either
  # an object, a list, or a templated string.
  extraEnvs: {}
  #extraEnvs:
  #  MY_ENV_VAR: value
  #  MY_OTHER_ENV_VAR: other_value
  #
  #extraEnvs:
  #  - name: MY_ENV_VAR
  #    value: value
  #  - name: MY_OTHER_ENV_VAR
  #    valueFrom:
  #      configMapRef:
  #        name: my-config-map
  #        value: my-key
  #
  #extraEnvs: |
  #  - name: RELEASE_NAMESPACE
  #    value: {{ .Release.Namespace }}

  # Sets the default Time To Live (TTL) for cached objects.
  ttl: 120

  # Sets the minimum number of worker threads in each pool.
  # See also https://varnish-cache.org/docs/6.0/reference/varnishd.html#thread-pool-min
  minThreads: 50

  # Sets the maximum number of worker threads in each pool.
  # See also https://varnish-cache.org/docs/6.0/reference/varnishd.html#thread-pool-max
  maxThreads: 1000

  # Sets the idle threshold where threads idle for at least this long will be destroyed.
  # See also https://varnish-cache.org/docs/6.0/reference/varnishd.html#thread-pool-timeout
  threadTimeout: 120

  # Sets the extra configuration args for Varnish Enterprise.
  extraArgs: []

  # Sets the Varnish Enterprise parameters (i.e. the -p argument).
  #
  # Varnish Enterprise parameters defined here will be translated from camelCase into
  # a snake_case. For example, a parameter named "backendIdleTimeout" will be transformed
  # into "backend_idle_timeout". If an array is given, it will be joined with a comma.
  parameters: {}
  #parameters:
  #  backendIdleTimeout: "60"
  #  feature:
  #    - "+http2"
  #    - "+validate_headers"

  # Declares the extra init containers to run before Varnish Enterprise pods are run.
  # Can be set as either a YAML list or a templated string.
  extraInitContainers: []
  #extraInitContainers: |
  #  - name: varnish-setup-tls
  #    securityContext:
  #      {{- toYaml .Values.global.securityContext | nindent 4 }}
  #    image: debian:latest
  #    command:
  #      - sh -c "sleep 3600"

  # Declares the extra sidecar containers to run with Varnish pods. Can be set as either
  # a YAML list or a templated string.
  extraContainers: []
  #extraContainers: |
  #  - name: varnish-hello
  #    securityContext:
  #      {{- toYaml .Values.global.securityContext | nindent 4 }}
  #    image: hello-world:latest
  #    volumeMounts:
  #      - name: {{ .Release.Name }}-varnish-vsm
  #        mountPath: /var/lib/varnish

  # Declares the extra volumeClaimTemplates. Can be set as either a YAML list or a
  # templated string. Only available when serverkind is set to StatefulSet.
  extraVolumeClaimTemplates: []
  #extraVolumeClaimTemplates: |
  #  - metadata:
  #      name: {{ .Release.Name }}-pv
  #    spec:
  #      accessModes: ["ReadWriteOnce"]
  #      resources:
  #        requests:
  #          storage: "10G"

  # Declares the extra volumes to mount with Varnish container. Can be set as either a
  # YAML list or a templated string.
  extraVolumeMounts: []
  #extraVolumeMounts: |
  #  - name: {{ .Release.Name }}-local-mse
  #    mountPath: /var/lib/mse

  # Declares the extra volumes to mount to the pod. Can be set as either a YAML list
  # or a templated string.
  extraVolumes: []
  #extraVolumes: |
  #  - name: {{ .Release.Name }}-local-mse
  #    hostPath:
  #      path: /data/mse
  #      type: Directory

  mse:
    # Enables Massive Storage Engine (version 3). Note that either one of server.mse.enabled or
    # server.mse4.enabled can be enabled at the same time. When set to "-", MSE will be enabled
    # or disabled based on an inverse value of server.mse4.enabled.
    enabled: "-"

    # Sets the MSE memory target. Can be specified as percentage ("80%") or a size ("20G").
    memoryTarget: ""

    # Configures the MSE backend. Can be set as a templated string. If set or not empty,
    # config will overrides the default configurations that are set when persistence.enabled
    # is true.
    #
    # See also https://docs.varnish-software.com/varnish-cache-plus/features/mse/
    config: ""
    #config: |
    #  env: {
    #    id = "env";
    #    memcache_size = "auto";
    #    books = ( {
    #      id = "book1";
    #      directory = "{{ .Values.server.mse.persistence.mountPath }}/book1";
    #      database_size = "1G";
    #      stores = ( {
    #        id = "store";
    #        filename = "{{ .Values.server.mse.persistence.mountPath }}/store1.dat";
    #        size = "9G";
    #      } );
    #    } );
    #  };

    # Use the content of the given file path as MSE configuration. The file will be
    # parsed as templated string. Will override "server.mse.config" if set. Note that
    # the file must be placed inside the files/ directory in the Helm chart
    # itself.
    configFile: ""
    #configFile: "files/mse.cfg"

    persistence:
      # Enables MSE persistency; only applicable if kind is "StatefulSet".
      # Note that the backing storage must be "ext4".
      enabled: false

      # Database size relative to storageSize, for auto-configuring MSE based on
      # server.mse.persistence.storageSize.
      #
      # Can be set as a percentage or a value.
      #
      # Both server.mse.persistence.bookSize and server.mse.persistence.storeSize
      # must add to up 100% or server.mse.persistence.storageSize. Only applicable
      # if server.mse.config is empty.
      bookSize: "1%"

      # Store size relative to storageSize, for auto-configuring MSE based on
      # server.mse.persistence.storageSize.
      #
      # Can be set as a percentage or a value.
      #
      # Both server.mse.persistence.bookSize and server.mse.persistence.storeSize
      # must add to up 100% or server.mse.persistence.storageSize. Only applicable
      # if server.mse.config is empty.
      storeSize: "91%"

      # Sets the mount path for Persistence Volume Claim for MSE.
      mountPath: "/var/lib/mse"

      # Sets the extra labels for Persistence Volume Claim for MSE.
      # Can be set as a templated string.
      labels: {}

      # Sets the extra annotations for Persistence Volume Claim for MSE.
      # Can be set as a templated string.
      annotations: {}

      # Sets the storage access modes for Persistence Volume Claim for MSE.
      accessModes: ["ReadWriteOnce"]

      # Sets the storage class for Persistence Volume Claim for MSE.
      storageClassName: ""

      # Sets the storage size for Persistence Volume Claim for MSE.
      storageSize: "10Gi"

  mse4:
    # Enables Massive Storage Engine (version 4). Note that either one of server.mse.enabled or
    # server.mse4.enabled can be enabled at the same time.
    enabled: false

    # Sets the MSE memory target. Can be specified as percentage ("80%") or a size ("20G").
    memoryTarget: ""

    # Configures the MSE4 backend. Can be set as a templated string. If set or not empty,
    # config will overrides the default configurations that are set when persistence.enabled
    # is true.
    config: ""

    # Use the content of the given file path as MSE4 configuration. The file will be
    # parsed as templated string. Will override "server.mse4.config" if set. Note that
    # the file must be placed inside the files/ directory in the Helm chart
    # itself.
    configFile: ""
    #configFile: "files/mse4.cfg"

    persistence:
      # Enables MSE4 persistency; only applicable if kind is "StatefulSet".
      # Note that the backing storage must be "ext4".
      enabled: false

      # Database size relative to storageSize, for auto-configuring MSE based on
      # server.mse.persistence.storageSize.
      #
      # Can be set as a percentage or a value.
      #
      # Both server.mse.persistence.bookSize and server.mse.persistence.storeSize
      # must add to up 100% or server.mse.persistence.storageSize. Only applicable
      # if server.mse.config is empty.
      bookSize: "1%"

      # Store size relative to storageSize, for auto-configuring MSE4 based on
      # server.mse.persistence.storageSize.
      #
      # Can be set as a percentage or a value.
      #
      # Both server.mse4.persistence.bookSize and server.mse4.persistence.storeSize
      # must add to up 100% or server.mse4.persistence.storageSize. Only applicable
      # if server.mse4.config is empty.
      storeSize: "91%"

      # Sets the mount path for Persistence Volume Claim for MSE4.
      mountPath: "/var/lib/mse4"

      # Sets the extra labels for Persistence Volume Claim for MSE4.
      # Can be set as a templated string.
      labels: {}

      # Sets the extra annotations for Persistence Volume Claim for MSE4.
      # Can be set as a templated string.
      annotations: {}

      # Sets the storage access modes for Persistence Volume Claim for MSE4.
      accessModes: ["ReadWriteOnce"]

      # Sets the storage class for Persistence Volume Claim for MSE4.
      storageClassName: ""

      # Sets the storage size for Persistence Volume Claim for MSE4.
      storageSize: "10Gi"

  # Sets the Varnish secret. If not set, Varnish will generate one on every Pod
  # start. Note that Varnish Controller require this value to be set. Either
  # server.secret or server.secretFrom can be set.
  secret: ""

  # Sets the Varnish secret from Kubernetes secret. Either server.secret
  # or server.secretFrom can be set.
  secretFrom: {}
  #secretFrom:
  #  name: secret-name
  #  key: varnish-secret

  # Use the content of the given file path as Varnish secret. The file will be
  # parsed as templated string. Will override "server.secret" if set. Note that
  # the file must be placed inside the files/ directory in the Helm chart
  # itself.
  secretFile: ""
  #secretFile: "files/secret"

  # Configures the path to the default VCL configuration file. This configuration
  # option also affects the location where `vclConfig` is mounted (if present).
  vclConfigPath: "/etc/varnish/default.vcl"

  # Configures the default VCL. Can be set as a templated string.
  vclConfig: ""

  # Use the content of the given file path as VCL configuration. The file will be
  # parsed as templated string. Will override "server.vclConfig" if set. Note that
  # the file must be placed inside the files/ directory in the Helm chart
  # itself.
  vclConfigFile: ""
  #vclConfigFile: "files/default.vcl"

  # Define an extra VCL configuration. Each key corresponds to the filename.
  # Can be set as a templated string. If "server.vclConfig" or "server.vclConfigFile"
  # is non-empty, setting default.vcl (or the same filename as specified in
  # `server.vclConfigPath`) here will result in an error.
  vclConfigs: {}
  #vclConfigs:
  #  main.vcl: |
  #    vcl 4.1;
  #
  #    backend default {
  #      .host = "127.0.0.1";
  #      .port = "8080";
  #    }

  # Configures the path to cmdfile. This configuration option also affects
  # the location where `cmdfileConfig` is mounted (if present).
  cmdfileConfigPath: "/etc/varnish/cmds.cli"

  # Configures the cmdfile. Can be set as a templated string.
  cmdfileConfig: ""

  # Use the content of the given file path as a cmdfile. The file will be
  # parsed as templated string. Will override "server.cmdfileConfig" if set.
  # Note that the file must be placed inside the files/ directory in the Helm
  # chart itself.
  cmdfileConfigFile: ""
  #cmdfileConfigFile: "files/cmds.cli"

  # Sets the base URL for Varnish Enterprise server. If left unset, it will
  # use the HTTP port and Pod IP to generate this URL.
  baseUrl: ""

  # Time to wait before Kubernetes sends SIGKILL to Pod while shutting down.
  terminationGracePeriodSeconds: 0

  # Delays stopping of the Varnish Enterprise container by the given seconds.
  # Deprecated: use `server.delayedShutdown` instead
  #delayedHaltSeconds: 0

  # Configures delayed shutdown for zero-downtime downscaling.
  delayedShutdown:
    # Delayed shutdown method. Can be one of:
    #
    #     none            Do not perform delayed shutdown
    #     sleep           Perform sleep in preStop for specific seconds
    #     mempool         Automatically determine if there is any active clients before shutting down
    #     shutdown_delay  Similar to sleep, but use shutdown_delay instead of preStop (6.0.13r2+)
    #
    # Note that when this value is set to anything other than "none"
    # `server.terminationGracePeriodSeconds` must also be set to the
    # maximum time it takes for Varnish Enterprise to shutdown.
    method: "none"

    # Configures "sleep" delayed shutdown method.
    sleep:
      seconds: 90

    # Configures "mempool" delayed shutdown method.
    mempool:
      # Poll the mempool session every given pollSeconds.
      pollSeconds: 1

      # Wait for the given waitSeconds before fully shutting down.
      waitSeconds: 5

    # Configures "shutdown_delay" delayed shutdown method.
    shutdownDelay:
      seconds: 90

  # Sets the image and tag to use to deploy Varnish Enterprise.
  # If tag is blank, appVersion is used.
  image:
    repository: "quay.io/varnish-software/varnish-plus"
    pullPolicy: IfNotPresent
    tag: ""

  # Enables or disables autoscaling.
  autoscaling:
    enabled: false

    # Sets the minimum number of replicas to keep active at all time.
    # When set to "-", uses the number from `server.replicas`.
    minReplicas: "-"

    # Sets the maximum number of replicas to spawn.
    maxReplicas: 100

    # Configures the behavior. Can be set as a template string or a
    # YAML map.
    behavior: ""
    #behavior: |
    #  scaleDown:
    #    stabilizationWindowSeconds: 120
    #    policies:
    #      - type: Percent
    #        value: 50
    #        periodSeconds: 60
    #  scaleUp:
    #    policies:
    #      - type: Percent
    #        value: 100
    #        periodSeconds: 60
    #      - type: Pods
    #        value: 4
    #        periodSeconds: 60
    #    selectPolicy: Max

    # Configures the autoscaling metrics. Can be set as a templated string
    # or a YAML map.
    metrics: ""
    #metrics: |
    #  - type: Resource
    #    resource:
    #      name: cpu
    #      targetAverageUtilization: 80

  # Enables or disables PodDisruptionBudget.
  # See also https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  pdb:
    enabled: false

    # Sets the minimum number of healthy pods to allow for disruption.
    minAvailable: ""

    # Sets the maximum number of unhealthy pods to allow for disruption.
    maxUnavailable: ""

  service:
    enabled: true

    # Sets the extra labels for Varnish Enterprise services. Can be set as a templated string.
    labels: {}

    # Sets the extra annotations for Varnish Enterprise services. Can be set as a templated string.
    annotations: {}

    # Type of the service. Can be ClusterIP or NodePort.
    #
    # See also https://kubernetes.io/docs/concepts/services-networking/service/
    type: NodePort

    # Sets whether to attach a Cluster IP address to the service. Services have Cluster IP
    # associated to it by default. Setting this to "None" will create a headless service,
    # which will allow the service IP to be resolved directly via DNS resolution (i.e. skipping
    # kube-proxy load-balancing).
    #
    # See also https://kubernetes.io/docs/concepts/services-networking/service/#headless-services
    clusterIP: ""

    # Sets a static load balancer IP address. Only applicable when server.service.type is "LoadBalancer"
    loadBalancerIP: ""

    # Enables or disables the Varnish HTTP service.
    http:
      enabled: true

      # Sets the port to listen HTTP service to.
      #
      # Note that when headless service is used (server.service.type set to "ClusterIP" and
      # server.service.clusterIP set to "None") the port defined here won't be used. Instead,
      # Varnish must be connected via the port defined in the pod (i.e., server.http.port).
      port: 80

      # Expose the service directly at the Node IP address at a specific port. Only applicable
      # when service type is set to "NodePort". Note that this port must be within the
      # Kubernetes' service-node-port-range (default: 30000-32767)
      #
      # See also https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
      #nodePort: 30080

    # Enables or disables the Varnish HTTPS service.
    https:
      enabled: false

      # Sets the port to listen HTTPS service to.
      #
      # Note that when headless service is used (server.service.type set to "ClusterIP" and
      # server.service.clusterIP set to "None") the port defined here won't be used. Instead,
      # Varnish must be connected via the port defined in the pod (i.e., server.tls.port).
      port: 443

      # Expose the service directly at the Node IP address at a specific port. Only applicable
      # when service type is set to "NodePort". Note that this port must be within the
      # Kubernetes' service-node-port-range (default: 30000-32767)
      #
      # See also https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
      #nodePort: 30443

    # Enables custom-defined extra services.
    #
    #     name        Name of the service. Required.
    #
    #     targetPort  The port in a pod to forward requests to. Must also be defined in
    #                 server.extraListens. Required.
    #
    #     port        The service port to listens. Note that this port is not used in case
    #                 of headless service. targetPort will be used instead in such case.
    #                 Required for non-headless services.
    #
    #     nodePort    Expose the service directly at Node IP address at a specific port.
    #                 Only applicable when service type is set to "NodePort".
    #
    extraServices: []
    #  - name: proxy
    #    targetPort: 8088
    #    port: 8088
    #    nodePort: 30888

    # Sets the external traffic policy for this service. externalTrafficPolicy describes how nodes distribute service
    # traffic they receive on one of the Service's "externally-facing" addresses (NodePorts, ExternalIPs, and
    # LoadBalancer IPs). Can be set to "Local" or "Cluster" (default)
    #
    # See also https://kubernetes.io/docs/reference/kubernetes-api/service-resources/service-v1/
    externalTrafficPolicy: Cluster

  ingress:
    enabled: false

    # Sets the extra labels for Varnish Enterprise ingress. Can be set as a templated string.
    labels: {}

    # Sets the extra annotations for Varnish Enterprise ingress. Can be set as a templated string.
    annotations: {}

    # Sets the class name for ingress.
    # See also https://kubernetes.io/docs/concepts/services-networking/ingress/#default-ingress-class
    ingressClassName: ""

    # Sets the pathType for Kubernetes 1.19+. "Prefix" should be sufficient for most cases.
    # See also https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types
    pathType: Prefix

    # Configures the hostname the Varnish Enterprise instance should respond to.
    hosts: []
    #  - host: chart-example.local
    #    paths: []

    # Configures TLS certificates for Ingress.
    tls: []
    #tls:
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  # Sets the extra annotations for Varnish Enterprise pod template. Can be set as a templated string.
  podAnnotations: {}
  #podAnnotations:
  #  prometheus.io/scrape: "true"
  #  prometheus.io/path: "/metrics"
  #  prometheus.io/port: "9273"
  #  prometheus.io/scheme: "http"

  # Sets the extra labels for Varnish Enterprise pod template. Can be set as a templated string.
  podLabels: {}
  #podLabels:
  #  varnish-software.com/tier: "edge"

  # Sets the securityContext of the Varnish Enterprise container.
  securityContext: {}

  # Configures a probe for checking if a Pod has started.
  startupProbe: {}
  #startupProbe:
  #  initialDelaySeconds: 5
  #  periodSeconds: 10
  #  timeoutSeconds: 1
  #  successThreshold: 1
  #  failureThreshold: 3

  # Configures a probe for checking if a Pod is ready to receive a connection.
  readinessProbe:
    # Sets the initial delays in seconds until the first probe is performed.
    initialDelaySeconds: 5

    # Sets the interval in seconds between each probes.
    periodSeconds: 10

    # Sets the timeout in seconds probe is considered timed out.
    timeoutSeconds: 1

    # Sets the consecutive successes until a probe is considered a success.
    successThreshold: 1

    # Sets the consecutive failures until a probe is considered a failure.
    failureThreshold: 3

  # Configures a probe for checking if a Pod has started.
  startupProbe: {}
  #startupProbe:
  #  initialDelaySeconds: 5
  #  periodSeconds: 10
  #  timeoutSeconds: 1
  #  successThreshold: 1
  #  failureThreshold: 3

  # Configures a probe for checking if a Pod can continue to receive a connection.
  livenessProbe:
    # Sets the initial delays in seconds until the first probe is performed.
    initialDelaySeconds: 30

    # Sets the interval in seconds between each probes.
    periodSeconds: 10

    # Sets the timeout in seconds probe is considered timed out.
    timeoutSeconds: 5

    # Sets the consecutive successes until a probe is considered a success.
    successThreshold: 1

    # Sets the consecutive failures until a probe is considered a failure.
    failureThreshold: 3

  # Configures a resource limits for Varnish Enterprise container.
  resources: {}
  #resources:
  #  limits:
  #    cpu: 100m
  #    memory: 128Mi
  #  requests:
  #    cpu: 100m
  #    memory: 128Mi

  # Configures a node selector to assign a Pod. Can be set as a templated string
  # or a YAML map.
  nodeSelector: {}
  #nodeSelector:
  #  beta.kubernetes.io/arch: amd64

  # Configures toleration settings for a Pod. Can be set as a templated string
  # or a YAML list.
  tolerations: []

  # Configures an affinity for a Pod. Can be set as a templated string or
  # a YAML map. By default, require Varnish to be deployed only on a node
  # it was not already deployed on.
  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ include "varnish-enterprise.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
          topologyKey: kubernetes.io/hostname
  
  # Configures the Varnish NCSA sidecar.
  varnishncsa:
    enabled: true

    # Sets the image and tag to use to deploy Varnish NCSA sidecar. Setting this to "-"
    # will inherit the same image as with server.image.
    image:
      repository: "-"
      pullPolicy: "-"
      tag: "-"

    # Sets the securityContext of the Varnish NCSA sidecar.
    securityContext: {}

    # Sets the extra arguments for Varnish NCSA sidecar.
    extraArgs:
      - -c

    # Configures a probe for checking if a Pod is ready to receive a connection.
    readinessProbe:
      # Sets the initial delays in seconds until the first probe is performed.
      initialDelaySeconds: 5

      # Sets the interval in seconds between each probes.
      periodSeconds: 10

      # Sets the timeout in seconds probe is considered timed out.
      timeoutSeconds: 1

      # Sets the consecutive successes until a probe is considered a success.
      successThreshold: 1

      # Sets the consecutive failures until a probe is considered a failure.
      failureThreshold: 3

    # Configures a probe for checking if a Pod can continue to receive a connection.
    livenessProbe:
      # Sets the initial delays in seconds until the first probe is performed.
      initialDelaySeconds: 30

      # Sets the interval in seconds between each probes.
      periodSeconds: 10

      # Sets the timeout in seconds probe is considered timed out.
      timeoutSeconds: 5

      # Sets the consecutive successes until a probe is considered a success.
      successThreshold: 1

      # Sets the consecutive failures until a probe is considered a failure.
      failureThreshold: 3

    # Configures a resource limits for Varnish NCSA container.
    resources: {}
    #resources:
    #  limits:
    #    cpu: 100m
    #    memory: 128Mi
    #  requests:
    #    cpu: 100m
    #    memory: 128Mi

  # Configures the Varnish Otel sidecar.
  otel:
    enabled: false

    # Sets the image and tag to use to deploy Varnish OTEL sidecar. Setting this to "-"
    # will inherit the same image as with server.image.
    image:
      repository: "-"
      pullPolicy: "-"
      tag: "-"

    # Sets the securityContext of the Varnish OTEL sidecar.
    securityContext: {}

    # Configures a resource limits for Varnish OTEL container.
    resources: {}

    # Environment variables for OTEL configuration
    env:
      # OTEL_LOGS_EXPORTER: "otlp"
      # OTEL_METRICS_EXPORTER: "otlp"
  # Configures the init container for Varnish Controller Agent.
  initAgent:
    # Whether to use init container to initialize Varnish Controller directory, or use
    # environment variable substitute method. This allows Varnish Controller Agent to
    # be accessed from a consistent VCL directory at /etc/varnish/agent.
    enabled: true

    # Sets the securityContext of Varnish Controller Agent init container.
    securityContext: {}

    # Declares the extra volumes to mount with Varnish Controller Agent init container.
    # Can be set as either a YAML list or a templated string.
    extraVolumeMounts: []
    #extraVolumeMounts: |
    #  - name: {{ .Release.Name }}-extra
    #    mountPath: /etc/varnish/extra

    # Configures a resource limits for Varnish Controller Agent init container.
    resources: {}
    #resources:
    #  limits:
    #    cpu: 100m
    #    memory: 128Mi
    #  requests:
    #    cpu: 100m
    #    memory: 128Mi

  # Configures Varnish Controller Agent sidecar for integration with Varnish Controller.
  agent:
    enabled: false

    # Sets the image and tag to use to deploy Varnish Controller Agent sidecar. The image
    # should be the same version as varnish-controller.
    image:
      repository: "quay.io/varnish-software/varnish-controller-agent"
      pullPolicy: IfNotPresent
      tag: "7.3.1-6.0.16r9"

    # Sets the securityContext of Varnish Controller Agent sidecar.
    securityContext: {}

    # Sets the log level for Varnish Controller Agent.
    logLevel: "debug"

    # Sets the private token.
    # See also https://docs.varnish-software.com/varnish-controller/concepts/privateshared/
    privateToken: ""

    # Sets the secret for using a varnish-enterprise.lic file.
    # See https://docs.varnish-software.com/varnish-helm/varnish-enterprise/installation/
    licenseSecret:

    # Sets the extra environment variables for Varnish Controller Agent.
    # Can be set as either an object, a list, or a templated string.
    extraEnvs: {}
    #extraEnvs:
    #  MY_ENV_VAR: value
    #  MY_OTHER_ENV_VAR: other_value
    #
    #extraEnvs:
    #  - name: MY_ENV_VAR
    #    value: value
    #  - name: MY_OTHER_ENV_VAR
    #    valueFrom:
    #      configMapRef:
    #        name: my-config-map
    #        value: my-key
    #
    #extraEnvs: |
    #  - name: RELEASE_NAMESPACE
    #    value: {{ .Release.Namespace }}

    # Sets the extra configuration args for Varnish Controller Agent.
    extraArgs: []

    # Sets the tag for this Varnish Controller Agent instance for use within
    # Varnish Controller.
    tags: []
    #tags:
    #  - tag1
    #  - tag2

    # Sets the location for this Varnish Controller Agent instance for
    # use within Varnish Controller Router.
    location: {}
    #location:
    #  longitude: "-121.955238"
    #  latitude: "37.354107"

    # Configures a resource limits for Varnish Controller Agent.
    resources: {}
    #resources:
    #  limits:
    #    cpu: 100m
    #    memory: 128Mi
    #  requests:
    #    cpu: 100m
    #    memory: 128Mi

    # Declares the extra volumes to mount with Varnish Controller Agent container.
    # Can be set as either a YAML list or a templated string.
    extraVolumeMounts: []
    #extraVolumeMounts: |
    #  - name: {{ .Release.Name }}-extra
    #    mountPath: /etc/varnish/extra

    # When server.replicas is set to 1, use the Helm release name as Agent Name instead
    # of relying on Pod name.
    useReleaseName: false

    persistence:
      # Enables Varnish Controller Agent state persistency; only applicable if kind is
      # "StatefulSet". If enabled, Varnish will be able to load last good configuration
      # deployed by Varnish Controller even when Varnish Controller is not running.
      enabled: false

      # Enables Varnish Controller Agent state persistency by specifying a custom
      # volume name. If set, "server.agent.persistence.enabled" will be ignored.
      # Intended to be used with extraVolumes (e.g. with DaemonSet and hostPath).
      enableWithVolumeName: ""

      # Sets the extra labels for Persistence Volume Claim for Varnish Controller Agent.
      # Can be set as a templated string.
      labels: {}

      # Sets the extra annotations for Persistence Volume Claim for Varnish Controller Agent.
      # Can be set as a templated string.
      annotations: {}

      # Sets the storage access modes for Persistence Volume Claim for Varnish Controller Agent.
      accessModes: ["ReadWriteOnce"]

      # Sets the storage class for Persistence Volume Claim for Varnish Controller Agent.
      storageClassName: ""

      # Sets the storage size for Persistence Volume Claim for Varnish Controller Agent.
      storageSize: "512Mi"

    # Enables auto-removal of Varnish Enterprise instance with Varnish Controller upon
    # pod rollout (e.g. during a redeployment).
    autoRemove:
      # Auto-remove method. Can be one of:
      #
      #     none            Do not perform auto removal
      #     vcli            Utilizes a VCLI sidecar to perform removal
      #
      method: none

      # Configures "vcli" auto-removal method.
      vcli:
        # Sets the image and tag to use to deploy Varnish Controller VCLI sidecar. The image
        # should be the same version as varnish-controller.
        image:
          repository: "quay.io/varnish-software/varnish-controller-cli"
          pullPolicy: IfNotPresent
          tag: "7.3.1"

        # Configures Varnish Controller Agent to use external Varnish Controller endpoint.
        # Ignored if `server.vcli.internal.enabled` is set to `true`.
        externalAddress: ""

        # Configures the username to connect to Varnish Controller API.
        username: admin

        # Configures NATS password as a string.
        password: ""

        # Configures NATS password from a Kubernetes secret. By default, it uses an
        # auto-generated password from a "varnish-controller-credentials" secret.
        passwordFrom:
          name: varnish-controller-credentials
          key: varnish-admin-password

        # Configures Varnish Controller CLI container to skip verifying the certificate when
        # communicating via HTTPS. This should be set to true if Varnish Controller is running
        # with a self-signed certificates.
        insecure: false

        internal:
          # Configures Varnish Controller CLI container to use an internal Varnish Controller endpoint.
          enabled: true

          # Configures the namespace Varnish Controller is deployed to. If left blank, the
          # current namespace is used.
          namespace: ""

          # Configures the release name Varnish Controller is deployed to. Use "varnish-controller"
          # if left blank.
          releaseName: ""

          # Configures the port of the Varnish Controller APIGW.
          port: 8080

          # Configures Varnish Controller CLI container to use HTTPS instead of HTTP to communicate
          # with the in-cluster Varnish Controller instance.
          https: false

          # Configures the NATS internal cluster domain name. Only change if NATS is deployed
          # on a separate cluster.
          clusterDomain: "cluster.local"

        # Sets the extra environment variables for Varnish Controller VCLI. Can be set as either
        # an object, a list, or a templated string.
        extraEnvs: {}
        #extraEnvs:
        #  MY_ENV_VAR: value
        #  MY_OTHER_ENV_VAR: other_value
        #
        #extraEnvs:
        #  - name: MY_ENV_VAR
        #    value: value
        #  - name: MY_OTHER_ENV_VAR
        #    valueFrom:
        #      configMapRef:
        #        name: my-config-map
        #        value: my-key
        #
        #extraEnvs: |
        #  - name: RELEASE_NAMESPACE
        #    value: {{ .Release.Namespace }}

        # Declares the extra volumes to mount with Varnish Controller VCLI. Can be set as either
        # a YAML list or a templated string.
        extraVolumeMounts: []
        #extraVolumeMounts: |
        #  - name: {{ .Release.Name }}-local-mse
        #    mountPath: /var/lib/mse


# A list of extra manifests to be deployed alongside with Helm chart.
#
#     name        The name of each manifest (will be used when checksum is true)
#
#     checksum    A boolean flag whether to include this manifest as part of the
#                 checksum in workload manifests. Useful for ConfigMaps.
#
#     data        The data of each manifest. Can be set as templated string.
#
extraManifests: []
#  - name: clusterrole
#    data: |
#      apiVersion: rbac.authorization.k8s.io/v1
#      kind: ClusterRole
#      metadata:
#        name: {{ .Release.Name }}-clusterrole
#      # ...


cluster:
  # Enables clustering will allow pods to shard requests between each others by:
  # - creating a headless service, even if server.service.clusterIP != None
  # - creating a secret token for pod to authorize peer-to-peer communication
  # - injecting a VCL preamble to your configuration
  enabled: false

  # Configures the headless service used by pods to discover each others. If empty,
  # the name defaults to `$VARNISH_SERVICE-peers` and the service is automatically
  # created.
  headlessServiceName: ""

  # Configures the token used by nodes to authorize peer-to-perr communication.
  # If empty, a `$VARNISH_SERVICE-cluster-secret` secret is automatically created.
  secretName: ""

  # Activates traces (https://docs.varnish-software.com/varnish-enterprise/features/cluster/#traces)
  trace: false
